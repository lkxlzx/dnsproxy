# 主动缓存刷新实现总结

## 问题解决

### 原始问题
**Q**: 冷却检查在缓存条目首次创建时进行。如果首次创建时不满足阈值，即使后续请求增加，也不会触发主动刷新。这会有什么影响？

**A**: 这会导致以下问题：
1. **冷启动问题**：新域名在"预热"阶段得不到主动刷新
2. **流量突增无响应**：域名突然变热门时，无法及时启用主动刷新
3. **用户体验下降**：高频域名在第一个 TTL 周期内得不到主动刷新的好处

### 解决方案：动态调度机制

实现了**智能动态调度**，在请求统计达到阈值时自动为现有缓存条目调度刷新。

## 核心改进

### 1. 增强的请求记录（滑动时间窗口）
```go
func (c *cache) recordRequest(key []byte) (justReachedThreshold bool)
```

**特性**：
- 使用**滑动时间窗口**机制
- 统计**跨越缓存周期**（不会在缓存过期时重置）
- 自动清理超出冷却周期的旧记录
- 返回是否刚刚达到阈值

**工作原理**：
```go
cutoff := now.Add(-c.cooldownPeriod)  // 例如：当前时间 - 30分钟
// 只统计 cutoff 之后的请求
```

**示例**（冷却周期 30 分钟）：
- 当前时间：12:00
- 统计范围：11:30 - 12:00 之间的所有请求
- 11:30 之前的请求自动被忽略

### 2. 动态调度方法
```go
func (c *cache) tryScheduleRefresh(key []byte, req *dns.Msg)
```
- 检查是否已调度（避免重复）
- 从缓存中提取剩余 TTL
- 计算合适的刷新延迟
- 创建定时器并调度

### 3. 集成到缓存命中流程
在 `get` 和 `getWithSubnet` 方法中：
```go
justReachedThreshold := c.recordRequest(key)
if justReachedThreshold && c.optimistic && ... {
    c.tryScheduleRefresh(key, req)
}
```

## 工作流程

### 场景：阈值为 3 的域名

#### 场景 A：正常情况（缓存命中）

```
时间轴：
T0: 首次请求 → 缓存创建 → 统计: [T0] → 不满足阈值 → 暂不调度
    ↓
T1: 第 2 次请求 → 缓存命中 → 统计: [T0, T1] → 仍不满足
    ↓
T2: 第 3 次请求 → 缓存命中 → 统计: [T0, T1, T2] → ✅ 达到阈值！
    ↓
    自动触发 tryScheduleRefresh()
    ↓
    计算剩余 TTL 和刷新延迟
    ↓
    创建定时器
    ↓
TTL - 刷新时间: 定时器触发 → 主动刷新
```

#### 场景 B：缓存过期但在冷却周期内

```
时间轴（冷却周期 = 30 分钟）：
T0 (0分钟):  首次请求 → 缓存创建 → 统计: [T0] → 不满足阈值
    ↓
[缓存过期，但统计保留]
    ↓
T1 (5分钟):  第 2 次请求 → 缓存未命中 → 重新创建缓存 → 统计: [T0, T1] → 仍不满足
    ↓
T2 (10分钟): 第 3 次请求 → 缓存命中 → 统计: [T0, T1, T2] → ✅ 达到阈值！
    ↓
    动态调度刷新
```

**关键点**：统计使用**滑动时间窗口**，跨越缓存周期。只要请求在冷却周期内，就会累积计数。

#### 场景 C：请求间隔超出冷却周期

```
时间轴（冷却周期 = 30 分钟）：
T0 (0分钟):   首次请求 → 统计: [T0]
    ↓
[等待 35 分钟，超出冷却周期]
    ↓
T1 (35分钟):  第 2 次请求 → 统计: [T1] (T0 被清除) → 重新计数
    ↓
T2 (40分钟):  第 3 次请求 → 统计: [T1, T2] → 仍不满足阈值 3
```

**结果**：请求间隔太长，统计被重置，不会触发刷新。这是**预期行为**，因为域名不够"热门"。

## 测试验证

### 测试用例：TestProactiveRefresh_DynamicThreshold
```go
// 1. 首次请求 - 只有 1 次，不调度
proxy.Resolve(dctx1)

// 2. 第二次请求 - 2 次，仍不调度
proxy.Resolve(dctx2)

// 3. 第三次请求 - 3 次，触发动态调度！
proxy.Resolve(dctx3)

// 4. 等待刷新时间
time.Sleep(2700 * time.Millisecond)

// 5. 验证：上游请求数增加（刷新成功）
assert.Greater(t, after, initial)
```

**结果**：✅ 测试通过，动态调度工作正常

## 性能影响

### 额外开销
- **内存**：每个缓存条目约 24-48 字节（请求统计）
- **CPU**：动态调度检查仅在达到阈值时触发，开销极小
- **网络**：无额外开销（只是改变调度时机）

### 基准测试
```
BenchmarkProactiveRefresh-16    1535964    787.9 ns/op
```
性能优秀，每次操作约 788 纳秒。

## 优势总结

### ✅ 解决的问题
1. **冷启动问题** - 新域名在达到阈值后自动启用刷新
2. **流量突增响应** - 域名变热门时立即启用刷新
3. **用户体验** - 高频域名始终保持最新

### ✅ 保持的优势
1. **资源高效** - 低频域名仍然不会被刷新
2. **性能优秀** - 只在达到阈值时调度一次
3. **无需重启** - 动态调整，实时生效

### ✅ 新增特性
1. **智能适应** - 自动适应流量变化
2. **零配置** - 无需额外配置，自动工作
3. **向后兼容** - 不影响现有功能

## 配置建议

### 默认配置（推荐）
```go
CacheProactiveRefreshTime: 30000        // 30秒
CacheProactiveCooldownPeriod: 1800      // 30分钟
CacheProactiveCooldownThreshold: 3      // 3次请求
```

### 激进配置（高实时性要求）
```go
CacheProactiveRefreshTime: 5000         // 5秒
CacheProactiveCooldownPeriod: 300       // 5分钟
CacheProactiveCooldownThreshold: 2      // 2次请求
```

### 保守配置（节省资源）
```go
CacheProactiveRefreshTime: 60000        // 60秒
CacheProactiveCooldownPeriod: 3600      // 60分钟
CacheProactiveCooldownThreshold: 10     // 10次请求
```

### 禁用冷却（刷新所有）
```go
CacheProactiveRefreshTime: 30000
CacheProactiveCooldownThreshold: -1     // 负数禁用冷却
```

## 关键特性 1：循环刷新保持热度

### 设计理念

对于热门域名，系统会**持续循环刷新**以保持缓存始终新鲜：

```
用户请求 → 缓存创建 → 达到阈值
    ↓
定时器调度（TTL - 刷新时间）
    ↓
主动刷新 → 新缓存 → 再次调度 ✅
    ↓
再次刷新 → 新缓存 → 再次调度 ✅
    ↓
循环往复，保持热度 🔄
```

### 停止条件

循环刷新会在以下情况自动停止：

1. **用户停止访问** → 请求统计过期 → 不满足冷却阈值 → 停止调度
2. **缓存被清空** → 定时器被取消
3. **代理关闭** → 所有定时器停止

### 测试验证

`TestProactiveRefresh_ContinuousRefresh` 验证了：
- TTL = 3 秒，刷新提前 1 秒
- 10 秒内产生 4 次刷新
- ✅ 循环刷新正常工作

`TestProactiveRefresh_StopsWhenCold` 验证了：
- 冷却周期过期后
- ✅ 刷新自动停止

## 关键特性 2：跨缓存周期统计

### 滑动时间窗口机制

统计使用**滑动时间窗口**，不会在缓存过期时重置：

```go
cutoff := now.Add(-c.cooldownPeriod)  // 只统计冷却周期内的请求
```

### 实际效果

| 场景 | 缓存状态 | 统计行为 | 结果 |
|------|---------|---------|------|
| 高频访问 | 多次命中 | 累积统计 | ✅ 触发刷新 |
| 缓存过期 | 未命中 → 重建 | **统计保留** | ✅ 继续累积 |
| 长时间无访问 | 超出冷却周期 | 统计重置 | ❌ 不触发刷新 |

### 测试验证

`TestProactiveRefresh_CrossCacheCycle` 验证了：
- T0: 首次请求 → 统计 1
- [缓存过期]
- T1: 第二次请求 → 统计 2（跨周期累积）
- T2: 第三次请求 → 统计 3 → ✅ 触发动态调度

## 总结

通过实现**动态调度机制**和**滑动时间窗口统计**，我们完美解决了原始实现的限制，使主动缓存刷新功能更加智能和实用。系统现在能够：

1. ✅ 自动识别流量模式变化
2. ✅ 动态调整刷新策略
3. ✅ 跨缓存周期累积统计
4. ✅ 保持高性能和低资源消耗
5. ✅ 提供更好的用户体验

**实现状态**：完成并通过所有测试 ✅（包括跨缓存周期测试）
