# 主动缓存刷新功能

## 概述

实现了乐观缓存的主动刷新机制，使缓存中的域名在 TTL 到期前自动刷新 IP，而不是被动等待过期后的请求触发刷新。同时引入冷却机制，防止低频访问的域名无限刷新，节省资源。

## 实现方式

### 核心机制

- **实时监控**：使用 `time.Timer` 为每个缓存条目创建独立的定时器
- **毫秒级精度**：刷新时间以毫秒为单位，支持精确控制
- **冷却机制**：跟踪域名请求频率，只刷新高频访问的域名
- **最小改动**：仅修改缓存模块，不影响其他组件

### 关键改动

1. **新增配置参数** (`proxy/config.go`)
   ```go
   // 刷新提前时间（毫秒）
   CacheProactiveRefreshTime int  // 默认 30000 (30秒)
   
   // 冷却周期（秒）
   CacheProactiveCooldownPeriod int  // 默认 1800 (30分钟)
   
   // 冷却阈值（请求次数）
   CacheProactiveCooldownThreshold int  // 默认 3
   ```

2. **缓存结构扩展** (`proxy/cache.go`)
   - `proactiveRefreshTime`：刷新提前时间（毫秒转换为 Duration）
   - `cooldownPeriod`：冷却周期
   - `cooldownThreshold`：最小请求次数阈值
   - `refreshTimers`：存储每个缓存条目的定时器
   - `requestStats`：跟踪每个域名的请求统计
   - `cr`：缓存解析器引用
   - `logger`：日志记录器

3. **请求统计**
   - `requestStat`：记录域名的请求时间戳
   - `recordRequest()`：记录每次缓存命中
   - `shouldProactiveRefresh()`：检查是否满足刷新条件

4. **定时器管理**
   - `scheduleRefresh()`：为缓存条目创建定时器（带冷却检查）
   - `executeRefresh()`：定时器触发时执行刷新
   - `refreshEntry()`：实际的刷新逻辑
   - `cancelAllTimers()`：清理所有定时器和统计数据

## 工作流程

### 1. 请求记录
- 每次缓存命中时记录时间戳
- 自动清理超出冷却周期的旧记录
- 统计数据存储在 `requestStats` 中

### 2. 缓存存储
当新的 DNS 响应被缓存时：
- 检查冷却机制：域名在冷却周期内的请求次数是否 ≥ 阈值
- 如果满足条件：
  - 计算刷新时间 = TTL - CacheProactiveRefreshTime
  - 如果刷新时间 > 0，创建定时器
- 如果不满足条件：跳过刷新，记录日志

### 3. 自动刷新
- 定时器到期时自动触发后台刷新
- 重建 DNS 请求并向上游查询
- 更新缓存（如果成功）
- 新的缓存条目会再次经过冷却检查

### 4. 清理机制
- 缓存清空时取消所有定时器和统计数据
- 代理关闭时停止所有刷新操作

## 使用示例

```go
proxy := &Proxy{
    CacheEnabled: true,
    CacheOptimistic: true,
    
    // TTL 到期前 30 秒（30000 毫秒）刷新
    CacheProactiveRefreshTime: 30000,
    
    // 30 分钟（1800 秒）内至少 3 次请求才刷新
    CacheProactiveCooldownPeriod: 1800,
    CacheProactiveCooldownThreshold: 3,
    
    // ... 其他配置
}
```

### 配置场景示例

**高频域名优先（默认）**
```go
CacheProactiveRefreshTime: 30000     // 30秒（毫秒）
CacheProactiveCooldownPeriod: 1800   // 30分钟（秒）
CacheProactiveCooldownThreshold: 3   // 3次
```
适用于大多数场景，只刷新经常访问的域名。

**激进刷新（禁用冷却）**
```go
CacheProactiveRefreshTime: 10000     // 10秒（毫秒）
CacheProactiveCooldownThreshold: 0   // 禁用冷却
```
刷新所有缓存条目，适用于对实时性要求极高的场景。

**极短 TTL 场景（毫秒级）**
```go
CacheProactiveRefreshTime: 500       // 0.5秒（毫秒）
CacheProactiveCooldownPeriod: 300    // 5分钟（秒）
CacheProactiveCooldownThreshold: 5   // 5次
```
适用于 TTL 极短（如 1-5 秒）的域名，在到期前 500ms 刷新。

**保守刷新（严格冷却）**
```go
CacheProactiveRefreshTime: 60000     // 60秒（毫秒）
CacheProactiveCooldownPeriod: 3600   // 60分钟（秒）
CacheProactiveCooldownThreshold: 10  // 10次
```
只刷新非常高频的域名，节省资源。

## 核心特性：循环刷新保持热度

### 🔄 持续刷新机制

热门域名会**持续循环刷新**以保持缓存始终新鲜：

```
用户请求 → 达到阈值 → 调度刷新
    ↓
主动刷新 → 新缓存 → 再次调度 ✅
    ↓
再次刷新 → 新缓存 → 再次调度 ✅
    ↓
持续循环，保持热度 🔄
```

**停止条件**：
- ❌ 用户停止访问 → 统计过期 → 自动停止
- ❌ 缓存清空或代理关闭

**示例**（TTL=60秒，刷新提前30秒）：
```
T0:  用户请求 → 缓存创建
T30: 主动刷新 → 新缓存（TTL=60秒）
T60: 再次刷新 → 新缓存（TTL=60秒）
T90: 继续刷新...
```
只要域名保持热度，就会一直刷新 ✅

## 优势

1. **保持热度**：热门域名缓存始终新鲜，循环刷新
2. **用户体验**：高频域名始终使用最新的 IP，避免过期缓存
3. **性能优化**：后台刷新不影响用户请求响应时间
4. **资源高效**：
   - 使用定时器而非轮询，CPU 占用低
   - 冷却机制避免刷新低频域名，减少网络请求
   - 冷门域名自动停止刷新
5. **灵活配置**：
   - 毫秒级精度控制刷新时机
   - 可调节冷却参数适应不同场景
6. **智能过滤**：自动识别并优先刷新热门域名

## 冷却机制详解

### 工作原理
1. 每次缓存存储和命中时记录时间戳
2. 在缓存条目首次存储时检查冷却条件
3. 如果满足条件，创建定时器进行主动刷新
4. **动态调度**：当请求统计达到阈值时，自动为现有缓存条目调度刷新
5. 定期清理超出冷却周期的旧记录

### 动态阈值激活

系统支持**动态调度机制**，解决冷启动问题：

**场景示例**（阈值设置为 3）：
1. **T0 时刻**：首次请求 → 缓存创建 → 记录 1 次 → 不满足阈值 → 暂不调度
2. **T1 时刻**：第 2 次请求 → 缓存命中 → 记录 2 次
3. **T2 时刻**：第 3 次请求 → 缓存命中 → 记录 3 次 → **达到阈值，动态调度刷新！**
4. **TTL - 刷新时间**：自动触发主动刷新

**优势**：
- ✅ 解决冷启动问题：新域名在"预热"后自动启用主动刷新
- ✅ 适应流量变化：域名突然变热门时，立即启用主动刷新
- ✅ 无需重启：动态调整，无需等待下一个 TTL 周期
- ✅ 性能优化：只在达到阈值时调度一次，避免频繁重新调度

### 示例场景
假设配置：
- 冷却周期：30 分钟
- 冷却阈值：3 次

**场景 1：高频域名（会刷新）**
- `example.com` 在 30 分钟内被请求 5 次
- 满足阈值 ≥ 3，会被主动刷新

**场景 2：低频域名（不刷新）**
- `rare-site.com` 在 30 分钟内只被请求 1 次
- 不满足阈值，跳过刷新，节省资源

**场景 3：流量突增（动态激活）**
- `trending.com` 首次请求时只有 1 次，不调度刷新
- 随后短时间内又有 2 次请求，总共 3 次
- 第 3 次请求时**自动触发动态调度**
- 在 TTL 到期前自动刷新

### 禁用冷却
设置 `CacheProactiveCooldownThreshold = 0` 可禁用冷却机制，刷新所有缓存条目。

## 性能与资源消耗

### 内存占用
- 每个缓存条目的请求统计：约 24-48 字节（取决于时间戳数量）
- 每个定时器：约 200 字节
- 总体影响：对于 10000 个缓存条目，额外内存约 2-3 MB

### CPU 开销
- 请求记录：~10 ns/op（几乎可忽略）
- 定时器调度：~788 ns/op（基准测试结果）
- 动态调度检查：仅在达到阈值时触发，开销极小

### 网络流量
- 主动刷新会增加上游请求
- 通过冷却机制可有效控制：只刷新高频域名
- 建议根据上游带宽和成本调整阈值

## 注意事项

- 仅在启用乐观缓存（`CacheOptimistic = true`）时生效
- TTL 小于或等于刷新提前时间的条目不会被主动刷新
- 刷新失败不影响现有缓存，会在日志中记录
- 冷却机制会占用少量内存存储请求统计
- 建议根据实际流量调整冷却参数
- 动态调度确保流量突增时也能及时启用主动刷新

## TTL 与刷新时间的关系

刷新条件：`TTL > CacheProactiveRefreshTime`

**示例：**
- TTL = 5 秒，刷新提前时间 = 500ms → ✓ 会刷新（在 4.5 秒时触发）
- TTL = 2 秒，刷新提前时间 = 500ms → ✓ 会刷新（在 1.5 秒时触发）
- TTL = 1 秒，刷新提前时间 = 1000ms → ✗ 不会刷新（TTL 太短）
- TTL = 500ms，刷新提前时间 = 500ms → ✗ 不会刷新（TTL 太短）

**最小可用配置：**
```go
// 对于 TTL = 1 秒的域名
CacheProactiveRefreshTime: 500  // 在 0.5 秒时刷新

// 对于 TTL = 2 秒的域名
CacheProactiveRefreshTime: 1000 // 在 1 秒时刷新
```
